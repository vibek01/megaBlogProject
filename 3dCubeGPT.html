<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Vibek – Full-Stack + 3D Cube</title>
  <!-- Elegant system font plus Poppins for headings -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* --- Global Reset & Fonts --- */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; width: 100%; overflow: hidden; }
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background: #000; /* fallback */
      color: #eee;
    }
    h1, h2 { font-family: 'Poppins', sans-serif; }

    /* --- Container & Layout --- */
    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    .text-side, .canvas-side {
      position: relative;
      flex: 1;
    }

    /* --- Text Side: Gradient + Backdrop Blur for Blend --- */
    .text-side {
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 2rem;
      /* fade from solid to transparent of the dark overlay */
      background: linear-gradient(
        to right,
        rgba(17,17,17,1) 0%,
        rgba(17,17,17,0.8) 30%,
        rgba(17,17,17,0.5) 60%,
        rgba(17,17,17,0) 100%
      );
      backdrop-filter: blur(4px);
    }

    /* --- Animated Headings --- */
    .text-side h1, .text-side h2 {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeInUp 1s ease-out forwards;
    }
    .text-side h1 {
      font-size: 3rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
      animation-delay: 0.2s;
      transition: transform 0.3s, color 0.3s;
      cursor: default;
    }
    .text-side h1:hover {
      color: #f0c674;
      transform: scale(1.05);
    }
    .text-side h2 {
      font-size: 1.5rem;
      font-weight: 400;
      animation-delay: 0.6s;
      transition: letter-spacing 0.3s, color 0.3s;
      cursor: default;
    }
    .text-side h2:hover {
      color: #8dc891;
      letter-spacing: 2px;
    }
    @keyframes fadeInUp {
      to { opacity: 1; transform: translateY(0); }
    }

    /* --- Canvas Side & Responsive --- */
    .canvas-side { overflow: hidden; }
    #canvas-container { width: 100%; height: 100%; display: block; }

    @media (max-width: 768px) {
      .container { flex-direction: column; }
      .text-side {
        align-items: center;
        text-align: center;
        padding: 1.5rem;
      }
      .text-side h1 { font-size: 2.5rem; }
      .text-side h2 { font-size: 1.25rem; }
      .canvas-side { height: 50vh; }
    }
  </style>
</head>
<body>

  <div class="container">
    <div class="text-side">
      <h1>Hi, I am Vibek</h1>
      <h2>Full Stack Developer</h2>
    </div>
    <div class="canvas-side">
      <div id="canvas-container"></div>
    </div>
  </div>

  <!-- Three.js & Helpers -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/lights/RectAreaLightUniformsLib.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/lights/RectAreaLight.js"></script>

  <script>
    // — Renderer & Scene Setup —
    const container = document.getElementById('canvas-container');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.physicallyCorrectLights = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.1;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 1000);
    camera.position.set(5, 5, 10);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // — Lighting —
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
    hemi.position.set(0, 20, 0);
    scene.add(hemi);

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
    rimLight.position.set(0, 10, 0);
    scene.add(rimLight);

    THREE.RectAreaLightUniformsLib.init();
    const frontArea = new THREE.RectAreaLight(0xffffff, 8, 6, 6);
    frontArea.position.set(0, 0, 8);
    frontArea.lookAt(0, 0, 0);
    scene.add(frontArea);

    const backArea = new THREE.RectAreaLight(0xffffff, 5, 6, 6);
    backArea.position.set(0, 0, -8);
    backArea.lookAt(0, 0, 0);
    scene.add(backArea);

    const p1 = new THREE.PointLight(0xffaa55, 0.4, 50);
    p1.position.set(10, 10, 10);
    scene.add(p1);

    const p2 = new THREE.PointLight(0x55aaff, 0.4, 50);
    p2.position.set(-10, -10, -10);
    scene.add(p2);

    // — Cube Pieces & Layers —
    function createRoundedBox(w,h,d,r,s) {
      const shape = new THREE.Shape();
      const eps = 1e-5, radius = r - eps;
      shape.absarc(eps, eps, eps, -Math.PI/2, -Math.PI, true);
      shape.absarc(eps, h-radius*2, eps, Math.PI, Math.PI/2, true);
      shape.absarc(w-radius*2, h-radius*2, eps, Math.PI/2, 0, true);
      shape.absarc(w-radius*2, eps, eps, 0, -Math.PI/2, true);
      const geom = new THREE.ExtrudeBufferGeometry(shape, {
        depth: d - r*2,
        bevelEnabled: true,
        bevelSegments: s*2,
        steps: 1,
        bevelSize: radius,
        bevelThickness: r,
        curveSegments: s
      });
      geom.center();
      return geom;
    }

    const cubeMat = new THREE.MeshStandardMaterial({
      color: '0x2a2a2a', metalness: 1, roughness: 0.1
    });

    const bottomLayer = new THREE.Group();
    const middleLayer = new THREE.Group();
    const topLayer    = new THREE.Group();
    const size = 1, gap = 0.08;

    for (let x=-1; x<=1; x++){
      for (let y=-1; y<=1; y++){
        for (let z=-1; z<=1; z++){
          const mesh = new THREE.Mesh(
            createRoundedBox(size,size,size,0.1,5),
            cubeMat
          );
          mesh.position.set(
            x*(size+gap),
            y*(size+gap),
            z*(size+gap)
          );
          if (y===-1)      bottomLayer.add(mesh);
          else if (y===0)  middleLayer.add(mesh);
          else             topLayer.add(mesh);
        }
      }
    }

    const cubeGroup = new THREE.Group();
    cubeGroup.add(bottomLayer, middleLayer, topLayer);
    scene.add(cubeGroup);
    keyLight.target = cubeGroup;

    // — Layer Rotation Queue & Loop —
    const originalQueue = [
      { group: bottomLayer, axis: 'y', angle: Math.PI/2 },
      { group: middleLayer, axis: 'y', angle: Math.PI/2 },
      { group: topLayer,    axis: 'y', angle: Math.PI/2 },
    ];
    let rotationQueue = originalQueue.map(o => ({...o}));
    let currentTurn = null;
    const layerSpeed = Math.PI/240; // ~2s per 90°

    // — Resize Handler —
    function onWindowResize(){
      const w = container.clientWidth;
      const h = container.clientHeight;
      renderer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onWindowResize);
    onWindowResize();

    // — Animate —
    const startTime = Date.now();
    function animate(){
      requestAnimationFrame(animate);
      const t = (Date.now() - startTime)*0.001;

      // Full-cube rotation
      cubeGroup.rotation.x = t*0.2;
      cubeGroup.rotation.y = t*0.3;

      // Layer turns (repeat queue)
      if (!currentTurn) {
        if (!rotationQueue.length) {
          rotationQueue = originalQueue.map(o => ({...o}));
        }
        currentTurn = rotationQueue.shift();
        currentTurn.remaining = currentTurn.angle;
      }
      if (currentTurn) {
        const step = Math.min(layerSpeed, Math.abs(currentTurn.remaining));
        const dir = Math.sign(currentTurn.remaining);
        currentTurn.group.rotation[currentTurn.axis] += dir*step;
        currentTurn.remaining -= dir*step;
        if (Math.abs(currentTurn.remaining) < 1e-3) {
          currentTurn = null;
        }
      }

      // Light pulsing
      p1.intensity = 0.4 + Math.sin(t*2)*0.2;
      p2.intensity = 0.4 + Math.cos(t*1.8)*0.2;

      // Key light follows camera
      keyLight.position.copy(camera.position);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>